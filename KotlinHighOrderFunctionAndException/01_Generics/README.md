# Основы Kotlin: функции высшего порядка, исключения
### Generics 
Задача
Цель задания
Вы научитесь работать с обобщенными классами и функциями, использовать вариантность.



Что входит в домашнее задание
Создать функцию, позволяющую фильтровать коллекцию целых и вещественных чисел по чётности.
Создать обобщённый класс очереди, которая будет хранить объекты любого типа в порядке очереди.
Создать обобщённый sealed-class, описывающий абстрактный результат операции. 


Задание 1. Функция, фильтрующая коллекцию целых и вещественных чисел по чётности


Что нужно сделать
Создайте generic-функцию, принимающую на вход список элементов типа T.
Отфильтруйте список таким образом, чтобы в нём остались только чётные элементы.
Верните из функции отфильтрованный список элементов типа T. Функция должна поддерживать списки любых типов, являющихся подтипами Number.
Отфильтруйте и выведите в консоль списки целых чисел и вещественных чисел.


Задание 2. Класс очереди, которая хранит объекты любого типа в порядке очереди


Что нужно сделать
Напишите класс Queue<T>, который представляет из себя очередь. Есть два метода:
enqueue(item: T) — item становится в конец очереди;
dequeue(): T? — достаёт из очереди первый объект, если очередь пуста - возвращается null.


Задание 3. Sealed-class, описывающий абстрактный результат операции


Что нужно сделать
Создайте sealed-class Result, который параметризован двумя типами — типом успешного результата (T) и типом ошибки (R). Наследуйтесь от него двумя классами:
Success<T, R> - data class, принимает в конструктор объект типа T;
Error<T, R> - data class, принимает в конструктор объект типа R.
Создайте функцию, которая возвращает объект типа Result<Int, String>. Сделайте так, чтобы результат функции можно было присвоить переменным со следующими типами:
Result<Number, String>
Result<Any, String>
И нельзя было присвоить переменным со следующими типами:

Result<Int, CharSequence>
Result<Int, Any>
то есть класс Result должен быть ковариантным по параметру T и инвариантным по параметру R.